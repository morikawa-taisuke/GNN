### 計画.md

---

## 1. データセットの準備と多様化

モデルが特定の音響空間に過学習せず、高い汎化性能を持つように、多様な残響特性を持つデータセットを作成します。

* **インパルス応答（IR）の収集と特徴量化**: 部屋の寸法、音源・マイクの位置、残響時間（$RT_{60}$）などのパラメータを多様に変化させてIRデータを生成します。この際、IRから**ケプストラム係数** や$RT_{60}$、$C_{50}$、$D_{50}$などの特徴量を抽出し、ファイルに保存します。
* **データ生成スクリプトの改変**: `generate_reverb_dataset.py`を拡張し、IRから抽出した残響特徴量も含む学習データを自動生成する機能を実装します。
* **データセットのフォーマット**: 生成した学習データセットを、`make_dataset.py`で扱われている`.npz`形式で保存します 。各ファイルには、入力音声、正解音声、そして抽出した残響特徴量を含めます。

---

## 2. 残響特徴量抽出エンコーダの実装

残響特性を学習する専用のエンコーダを実装し、これをモデルの中間層に組み込みます。

* **モデル構造の設計**: `ConvTasNet_models.py`の`TCN`モジュールや`models/GNN.py`の1D畳み込み層を参考に、時間的コンテキストを考慮したCNN-RNNベースのエンコーダを実装します 。
* **出力の設計**: このエンコーダの出力は、グラフ構築や補助損失計算で扱いやすいように、次元を調整した「残響特徴量」とします。
* **既存モデルへの統合**: 新しいエンコーダを、`models/SpeqGNN.py`や`models/GNN_encoder.py`といった既存モデルの中間層として統合します。

---

## 3. グラフ構築ロジックの改変

学習した残響特徴量をグラフ構造に反映させます。

* **`GraphBuilder`の改変**: `models/graph_utils.py`にある`EdgeSelectionType.KNN`のロジックを修正します 。
* **エッジ重みの生成**: 既存のノード特徴量ではなく、ステップ2で抽出した「残響特徴量」を入力として、ノード間の類似度（例: コサイン類似度）を計算します。
* **GNN層への適用**: `GCNConv`や`GATConv`の`edge_weight`引数に対応する形で、計算した類似度をエッジの重みとしてGNN層に渡すようにモデルを修正します。

---

## 4. マルチタスク学習の導入

モデルの学習目標を複数化し、残響除去性能を明示的に向上させます。

* **補助損失関数の定義**: `mymodule/LossFunction.py`に、中間特徴量と正解の残響特徴量（ケプストラム係数など）との距離を計算する新しい損失関数を追加します 。
* **`Trainer`の改変**: `TrainerClass.py`などの学習スクリプトを修正し、最終的な出力損失に加えて、この補助損失を加算する**マルチタスク損失**を構築します 。
* **ハイパーパラメータの調整**: 各損失項のバランスを調整する重み（`α`, `β`など）を導入し、実験を通じて最適な組み合わせを見つけます。

---

## 5. 実験と評価

モデルの学習と性能評価を繰り返し行い、改善を図ります。

* **学習の実行**: ステップ4で定義したマルチタスク学習を実行し、モデルを学習させます。
* **客観評価**: `All_evaluation.py`や`evaluation/cepsdist.py`を用いて、モデルの性能を客観的に評価します 。
* **結果の分析**: 最終的な音源強調の評価指標（`PESQ`, `STOI`, `SI-SDR`）だけでなく、残響特徴量の損失が学習中にどのように変化したか、またその値が最終的な性能にどう影響したかを分析します。